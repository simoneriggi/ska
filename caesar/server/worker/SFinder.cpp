/*----- PROTECTED REGION ID(SFinder.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        SFinder.cpp
//
// description : C++ source for the SFinder class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SFinder are implemented in this file.
//
// project :     Source finder worker
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SFinder.h>
#include <SFinderClass.h>

#include <TFile.h>

#include <Img.h>
#include <BkgData.h>
#include <Logger.h>
using namespace Caesar;

/*----- PROTECTED REGION END -----*/	//	SFinder.cpp

/**
 *  SFinder class description:
 *    Device server for source finding.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name    |  Method name
//================================================================
//  State           |  Inherited (no method)
//  Status          |  Inherited (no method)
//  ExtractSources  |  extract_sources
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  useLocalBkg             |  Tango::DevBoolean	Scalar
//  use2ndPassInLocalBkg    |  Tango::DevBoolean	Scalar
//  skipNegativePixels      |  Tango::DevBoolean	Scalar
//  skipOutliersInLocalBkg  |  Tango::DevBoolean	Scalar
//  localBkgMethod          |  Tango::DevShort	Scalar
//  bkgEstimator            |  Tango::DevShort	Scalar
//  useBeamInfoInBkg        |  Tango::DevBoolean	Scalar
//  localBkgBoxSizeX        |  Tango::DevFloat	Scalar
//  localBkgBoxSizeY        |  Tango::DevFloat	Scalar
//  localBkgGridStepSizeX   |  Tango::DevFloat	Scalar
//  localBkgGridStepSizeY   |  Tango::DevFloat	Scalar
//  seedThr                 |  Tango::DevFloat	Scalar
//  mergeThr                |  Tango::DevFloat	Scalar
//  minNPix                 |  Tango::DevLong	Scalar
//  mergeBelowSeed          |  Tango::DevBoolean	Scalar
//  searchNegativeExcess    |  Tango::DevBoolean	Scalar
//  nestedBlobThrFactor     |  Tango::DevFloat	Scalar
//  searchCompactSources    |  Tango::DevBoolean	Scalar
//================================================================

namespace SFinder_ns
{
/*----- PROTECTED REGION ID(SFinder::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	SFinder::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : SFinder::SFinder()
 *	Description : Constructors for a Tango device
 *                implementing the classSFinder
 */
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SFinder::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_1
}
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(SFinder::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_2
}
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(SFinder::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SFinder::delete_device()
{
	DEBUG_STREAM << "SFinder::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void SFinder::init_device()
{
	DEBUG_STREAM << "SFinder::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(SFinder::init_device) ENABLED START -----*/
	
	//	Initialize device
	set_state(Tango::ON);
	set_status("Worker "+device_name +" started");
	DEBUG_STREAM<<"SFinder::init_device() - Worker "<<device_name<<" started..."<<endl;

	//## Init default attr values
	LoadDefaultConfig();

	
	/*----- PROTECTED REGION END -----*/	//	SFinder::init_device
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void SFinder::get_device_property()
{
	/*----- PROTECTED REGION ID(SFinder::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("useLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("use2ndPassInLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("skipNegativePixels_default"));
	dev_prop.push_back(Tango::DbDatum("skipOutliersInLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgMethod_default"));
	dev_prop.push_back(Tango::DbDatum("bkgEstimator_default"));
	dev_prop.push_back(Tango::DbDatum("useBeamInfoInBkg_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgBoxSizeX_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgBoxSizeY_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgGridStepSizeX_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgGridStepSizeY_default"));
	dev_prop.push_back(Tango::DbDatum("seedThr_default"));
	dev_prop.push_back(Tango::DbDatum("mergeThr_default"));
	dev_prop.push_back(Tango::DbDatum("minNPix_default"));
	dev_prop.push_back(Tango::DbDatum("mergeBelowSeed_default"));
	dev_prop.push_back(Tango::DbDatum("searchNegativeExcess_default"));
	dev_prop.push_back(Tango::DbDatum("searchNestedSources_default"));
	dev_prop.push_back(Tango::DbDatum("nestedBlobThrFactor_default"));
	dev_prop.push_back(Tango::DbDatum("searchCompactSources_default"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SFinderClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SFinderClass	*ds_class =
			(static_cast<SFinderClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize useLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useLocalBkg_default;
		else {
			//	Try to initialize useLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useLocalBkg_default;
		}
		//	And try to extract useLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useLocalBkg_default;

		//	Try to initialize use2ndPassInLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  use2ndPassInLocalBkg_default;
		else {
			//	Try to initialize use2ndPassInLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  use2ndPassInLocalBkg_default;
		}
		//	And try to extract use2ndPassInLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  use2ndPassInLocalBkg_default;

		//	Try to initialize skipNegativePixels_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skipNegativePixels_default;
		else {
			//	Try to initialize skipNegativePixels_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skipNegativePixels_default;
		}
		//	And try to extract skipNegativePixels_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skipNegativePixels_default;

		//	Try to initialize skipOutliersInLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skipOutliersInLocalBkg_default;
		else {
			//	Try to initialize skipOutliersInLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skipOutliersInLocalBkg_default;
		}
		//	And try to extract skipOutliersInLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skipOutliersInLocalBkg_default;

		//	Try to initialize localBkgMethod_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgMethod_default;
		else {
			//	Try to initialize localBkgMethod_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgMethod_default;
		}
		//	And try to extract localBkgMethod_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgMethod_default;

		//	Try to initialize bkgEstimator_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  bkgEstimator_default;
		else {
			//	Try to initialize bkgEstimator_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  bkgEstimator_default;
		}
		//	And try to extract bkgEstimator_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  bkgEstimator_default;

		//	Try to initialize useBeamInfoInBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useBeamInfoInBkg_default;
		else {
			//	Try to initialize useBeamInfoInBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useBeamInfoInBkg_default;
		}
		//	And try to extract useBeamInfoInBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useBeamInfoInBkg_default;

		//	Try to initialize localBkgBoxSizeX_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgBoxSizeX_default;
		else {
			//	Try to initialize localBkgBoxSizeX_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgBoxSizeX_default;
		}
		//	And try to extract localBkgBoxSizeX_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgBoxSizeX_default;

		//	Try to initialize localBkgBoxSizeY_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgBoxSizeY_default;
		else {
			//	Try to initialize localBkgBoxSizeY_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgBoxSizeY_default;
		}
		//	And try to extract localBkgBoxSizeY_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgBoxSizeY_default;

		//	Try to initialize localBkgGridStepSizeX_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgGridStepSizeX_default;
		else {
			//	Try to initialize localBkgGridStepSizeX_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgGridStepSizeX_default;
		}
		//	And try to extract localBkgGridStepSizeX_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgGridStepSizeX_default;

		//	Try to initialize localBkgGridStepSizeY_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgGridStepSizeY_default;
		else {
			//	Try to initialize localBkgGridStepSizeY_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgGridStepSizeY_default;
		}
		//	And try to extract localBkgGridStepSizeY_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgGridStepSizeY_default;

		//	Try to initialize seedThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  seedThr_default;
		else {
			//	Try to initialize seedThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  seedThr_default;
		}
		//	And try to extract seedThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  seedThr_default;

		//	Try to initialize mergeThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  mergeThr_default;
		else {
			//	Try to initialize mergeThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  mergeThr_default;
		}
		//	And try to extract mergeThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  mergeThr_default;

		//	Try to initialize minNPix_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  minNPix_default;
		else {
			//	Try to initialize minNPix_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  minNPix_default;
		}
		//	And try to extract minNPix_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  minNPix_default;

		//	Try to initialize mergeBelowSeed_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  mergeBelowSeed_default;
		else {
			//	Try to initialize mergeBelowSeed_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  mergeBelowSeed_default;
		}
		//	And try to extract mergeBelowSeed_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  mergeBelowSeed_default;

		//	Try to initialize searchNegativeExcess_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchNegativeExcess_default;
		else {
			//	Try to initialize searchNegativeExcess_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchNegativeExcess_default;
		}
		//	And try to extract searchNegativeExcess_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchNegativeExcess_default;

		//	Try to initialize searchNestedSources_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchNestedSources_default;
		else {
			//	Try to initialize searchNestedSources_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchNestedSources_default;
		}
		//	And try to extract searchNestedSources_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchNestedSources_default;

		//	Try to initialize nestedBlobThrFactor_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  nestedBlobThrFactor_default;
		else {
			//	Try to initialize nestedBlobThrFactor_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  nestedBlobThrFactor_default;
		}
		//	And try to extract nestedBlobThrFactor_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  nestedBlobThrFactor_default;

		//	Try to initialize searchCompactSources_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchCompactSources_default;
		else {
			//	Try to initialize searchCompactSources_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchCompactSources_default;
		}
		//	And try to extract searchCompactSources_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchCompactSources_default;

	}

	/*----- PROTECTED REGION ID(SFinder::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SFinder::always_executed_hook()
{
	DEBUG_STREAM << "SFinder::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void SFinder::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SFinder::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : SFinder::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void SFinder::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SFinder::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute useLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useLocalBkg_read);
	attr.set_value(&attr_useLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute useLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_useLocalBkg_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute use2ndPassInLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_use2ndPassInLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_use2ndPassInLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_use2ndPassInLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_use2ndPassInLocalBkg_read);
	attr.set_value(&attr_use2ndPassInLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_use2ndPassInLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute use2ndPassInLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_use2ndPassInLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_use2ndPassInLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_use2ndPassInLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_use2ndPassInLocalBkg_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_use2ndPassInLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute skipNegativePixels related method
 *	Description: Flag to skip/keep negative pixels when computing the image stats
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_skipNegativePixels(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_skipNegativePixels(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_skipNegativePixels) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_skipNegativePixels_read);
	attr.set_value(&attr_skipNegativePixels_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_skipNegativePixels
}
//--------------------------------------------------------
/**
 *	Write attribute skipNegativePixels related method
 *	Description: Flag to skip/keep negative pixels when computing the image stats
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_skipNegativePixels(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_skipNegativePixels(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_skipNegativePixels) ENABLED START -----*/
	attr.get_write_value(attr_skipNegativePixels_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_skipNegativePixels
}
//--------------------------------------------------------
/**
 *	Read attribute skipOutliersInLocalBkg related method
 *	Description: Flag to enable/disable skipping outliers in local bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_skipOutliersInLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_skipOutliersInLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_skipOutliersInLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_skipOutliersInLocalBkg_read);
	attr.set_value(&attr_skipOutliersInLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_skipOutliersInLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute skipOutliersInLocalBkg related method
 *	Description: Flag to enable/disable skipping outliers in local bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_skipOutliersInLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_skipOutliersInLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_skipOutliersInLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_skipOutliersInLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_skipOutliersInLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgMethod related method
 *	Description: Method used to compute local bkg (1=Grid, 2=Superpixel)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgMethod(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgMethod(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgMethod) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgMethod_read);
	attr.set_value(&attr_localBkgMethod_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgMethod
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgMethod related method
 *	Description: Method used to compute local bkg (1=Grid, 2=Superpixel)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgMethod(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgMethod(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgMethod) ENABLED START -----*/
	attr.get_write_value(attr_localBkgMethod_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgMethod
}
//--------------------------------------------------------
/**
 *	Read attribute bkgEstimator related method
 *	Description: Estimator to be used to compute bkg 
 *               (1=mean, 2=median, 3=biweight, 4=clipped median)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_bkgEstimator(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_bkgEstimator(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_bkgEstimator) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_bkgEstimator_read);
	attr.set_value(&attr_bkgEstimator_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_bkgEstimator
}
//--------------------------------------------------------
/**
 *	Write attribute bkgEstimator related method
 *	Description: Estimator to be used to compute bkg 
 *               (1=mean, 2=median, 3=biweight, 4=clipped median)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_bkgEstimator(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_bkgEstimator(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_bkgEstimator) ENABLED START -----*/
	attr.get_write_value(attr_bkgEstimator_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_bkgEstimator
}
//--------------------------------------------------------
/**
 *	Read attribute useBeamInfoInBkg related method
 *	Description: Use beam information in bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useBeamInfoInBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useBeamInfoInBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useBeamInfoInBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useBeamInfoInBkg_read);
	attr.set_value(&attr_useBeamInfoInBkg_write);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useBeamInfoInBkg
}
//--------------------------------------------------------
/**
 *	Write attribute useBeamInfoInBkg related method
 *	Description: Use beam information in bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useBeamInfoInBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useBeamInfoInBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useBeamInfoInBkg) ENABLED START -----*/
	attr.get_write_value(attr_useBeamInfoInBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useBeamInfoInBkg
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgBoxSizeX related method
 *	Description: Box size X used for local bkg computation. If beam information is used, this corresponds to 
 *               a multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgBoxSizeX(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgBoxSizeX(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgBoxSizeX) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgBoxSizeX_read);
	attr.set_value(&attr_localBkgBoxSizeX_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgBoxSizeX
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgBoxSizeX related method
 *	Description: Box size X used for local bkg computation. If beam information is used, this corresponds to 
 *               a multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgBoxSizeX(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgBoxSizeX(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgBoxSizeX) ENABLED START -----*/
	attr.get_write_value(attr_localBkgBoxSizeX_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgBoxSizeX
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgBoxSizeY related method
 *	Description: Box size Y used for local bkg computation. If beam information is used, this corresponds to a
 *               multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgBoxSizeY(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgBoxSizeY(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgBoxSizeY) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgBoxSizeY_read);
	attr.set_value(&attr_localBkgBoxSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgBoxSizeY
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgBoxSizeY related method
 *	Description: Box size Y used for local bkg computation. If beam information is used, this corresponds to a
 *               multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgBoxSizeY(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgBoxSizeY(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgBoxSizeY) ENABLED START -----*/
	attr.get_write_value(attr_localBkgBoxSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgBoxSizeY
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgGridStepSizeX related method
 *	Description: Grid step size X used in local bkg computation. This corresponds to a fraction of the box 
 *               size X (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgGridStepSizeX(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgGridStepSizeX(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgGridStepSizeX) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgGridStepSizeX_read);
	attr.set_value(&attr_localBkgGridStepSizeX_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgGridStepSizeX
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgGridStepSizeX related method
 *	Description: Grid step size X used in local bkg computation. This corresponds to a fraction of the box 
 *               size X (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgGridStepSizeX(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgGridStepSizeX(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgGridStepSizeX) ENABLED START -----*/
	attr.get_write_value(attr_localBkgGridStepSizeX_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgGridStepSizeX
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgGridStepSizeY related method
 *	Description: Grid step size Y used in local bkg computation. This corresponds to a fraction of the box size Y 
 *               (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgGridStepSizeY(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgGridStepSizeY(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgGridStepSizeY) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgGridStepSizeY_read);
	attr.set_value(&attr_localBkgGridStepSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgGridStepSizeY
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgGridStepSizeY related method
 *	Description: Grid step size Y used in local bkg computation. This corresponds to a fraction of the box size Y 
 *               (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgGridStepSizeY(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgGridStepSizeY(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgGridStepSizeY) ENABLED START -----*/
	attr.get_write_value(attr_localBkgGridStepSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgGridStepSizeY
}
//--------------------------------------------------------
/**
 *	Read attribute seedThr related method
 *	Description: Seed threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_seedThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_seedThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_seedThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_seedThr_read);
	attr.set_value(&attr_seedThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_seedThr
}
//--------------------------------------------------------
/**
 *	Write attribute seedThr related method
 *	Description: Seed threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_seedThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_seedThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_seedThr) ENABLED START -----*/
	attr.get_write_value(attr_seedThr_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_seedThr
}
//--------------------------------------------------------
/**
 *	Read attribute mergeThr related method
 *	Description: Merge threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_mergeThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_mergeThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_mergeThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_mergeThr_read);
	attr.set_value(&attr_mergeThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_mergeThr
}
//--------------------------------------------------------
/**
 *	Write attribute mergeThr related method
 *	Description: Merge threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_mergeThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_mergeThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_mergeThr) ENABLED START -----*/
	attr.get_write_value(attr_mergeThr_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_mergeThr
}
//--------------------------------------------------------
/**
 *	Read attribute minNPix related method
 *	Description: Minimum number of pixels in source fnding (blob size in flood-fill).
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_minNPix(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_minNPix(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_minNPix) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_minNPix_read);
	attr.set_value(&attr_minNPix_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_minNPix
}
//--------------------------------------------------------
/**
 *	Write attribute minNPix related method
 *	Description: Minimum number of pixels in source fnding (blob size in flood-fill).
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_minNPix(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_minNPix(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_minNPix) ENABLED START -----*/
	attr.get_write_value(attr_minNPix_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_minNPix
}
//--------------------------------------------------------
/**
 *	Read attribute mergeBelowSeed related method
 *	Description: Flag value to aggregate only pixels below seed threshold in flood-fill
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_mergeBelowSeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_mergeBelowSeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_mergeBelowSeed) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_mergeBelowSeed_read);
	attr.set_value(&attr_mergeBelowSeed_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_mergeBelowSeed
}
//--------------------------------------------------------
/**
 *	Write attribute mergeBelowSeed related method
 *	Description: Flag value to aggregate only pixels below seed threshold in flood-fill
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_mergeBelowSeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_mergeBelowSeed(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_mergeBelowSeed) ENABLED START -----*/
	attr.get_write_value(attr_mergeBelowSeed_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_mergeBelowSeed
}
//--------------------------------------------------------
/**
 *	Read attribute searchNegativeExcess related method
 *	Description: Flag to search negative excess together with positive in compact source search
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_searchNegativeExcess(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_searchNegativeExcess(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_searchNegativeExcess) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_searchNegativeExcess_read);
	attr.set_value(&attr_searchNegativeExcess_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_searchNegativeExcess
}
//--------------------------------------------------------
/**
 *	Write attribute searchNegativeExcess related method
 *	Description: Flag to search negative excess together with positive in compact source search
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_searchNegativeExcess(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_searchNegativeExcess(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_searchNegativeExcess) ENABLED START -----*/
	attr.get_write_value(attr_searchNegativeExcess_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_searchNegativeExcess
}
//--------------------------------------------------------
/**
 *	Read attribute nestedBlobThrFactor related method
 *	Description: Threshold (in multiple of curvature RMS) to be used to detect nested blobs
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_nestedBlobThrFactor(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_nestedBlobThrFactor(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_nestedBlobThrFactor) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_nestedBlobThrFactor_read);
	attr.set_value(&attr_nestedBlobThrFactor_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_nestedBlobThrFactor
}
//--------------------------------------------------------
/**
 *	Write attribute nestedBlobThrFactor related method
 *	Description: Threshold (in multiple of curvature RMS) to be used to detect nested blobs
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_nestedBlobThrFactor(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_nestedBlobThrFactor(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_nestedBlobThrFactor) ENABLED START -----*/
	attr.get_write_value(attr_nestedBlobThrFactor_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_nestedBlobThrFactor
}
//--------------------------------------------------------
/**
 *	Read attribute searchCompactSources related method
 *	Description: Flag to enable/disable search of compact sources
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_searchCompactSources(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_searchCompactSources(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_searchCompactSources) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_searchCompactSources_read);
	attr.set_value(&attr_searchCompactSources_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_searchCompactSources
}
//--------------------------------------------------------
/**
 *	Write attribute searchCompactSources related method
 *	Description: Flag to enable/disable search of compact sources
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_searchCompactSources(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_searchCompactSources(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_searchCompactSources) ENABLED START -----*/
	attr.get_write_value(attr_searchCompactSources_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_searchCompactSources
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void SFinder::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(SFinder::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command ExtractSources related method
 *	Description: Find sources in map using the configuration passed 
 *               as argument.
 *
 *	@param argin String arg
 *               [0]: filename 
 *               
 *               Long arg
 *               [nmaps+0]: tile min x
 *               [nmaps+1]: tile max x
 *               [nmaps+2]: tile min y
 *               [nmaps+3]: tile max y
 *	@returns Long arg
 *           [0]: ack code
 *           
 *           String arg
 *           [0]: Encoded sources found
 *           [1]: err description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SFinder::extract_sources(const Tango::DevVarLongStringArray *argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SFinder::ExtractSources()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::extract_sources) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);

	//Validate args	
	long int nArgs_s= argin->svalue.length();
	long int nArgs_l= argin->lvalue.length();
	if(nArgs_s<=0){
		WARN_LOG("Missing filename argument given!");
		ack= -1;
		reply= "Missing filename argument given!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	if(strcmp(argin->svalue[0],"")==0){
		WARN_LOG("Empty filename argument given!");
		ack= -1;
		reply= "Invalid filename argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	if(nArgs_l%4!=0){
		WARN_LOG("Invalid image range argument given!");
		ack= -1;
		reply= "Invalid image range argument given!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	
	std::string inputFileName= std::string(argin->svalue[0]); 
	long int nTasks= (long int)(nArgs_l/4);	
	std::vector<long int> tileMinX_list(nTasks,-1);
	std::vector<long int> tileMaxX_list(nTasks,-1);
	std::vector<long int> tileMinY_list(nTasks,-1);
	std::vector<long int> tileMaxY_list(nTasks,-1);	
	if(nArgs_l>0){
		INFO_LOG("Reading tile image(s)...");
		for(long int i=0;i<nTasks;i++){
			long int index= 4*i;
			tileMinX_list[i]= argin->lvalue[index+0]; 
			tileMaxX_list[i]= argin->lvalue[index+1];
			tileMinY_list[i]= argin->lvalue[index+2]; 
			tileMaxY_list[i]= argin->lvalue[index+3];
		}
	}
	
	//Set RUNNING state
	set_state(Tango::RUNNING);
	set_status("Source finding started");
	INFO_LOG("Source finding started");

	
	//## Source finding tasks
	INFO_LOG("Starting source finding tasks (Ntasks="<<nTasks<<") ...");
	std::vector<Source*> sources;
	for(long int i=0;i<nTasks;i++){
		INFO_LOG("Starting source finding task no. "<<i+1<<"...");
		int status= RunSourceTask(sources,inputFileName,tileMinX_list[i],tileMaxX_list[i],tileMinY_list[i],tileMaxY_list[i]);
		if(status<0){
			ERROR_LOG("Source finding task failed for reco task no. "<<i+1<<"!");
			ack= -1;
			reply= "Source finding task failed!";
			argout->lvalue[0]= ack;
			argout->svalue[0] = CORBA::string_dup(reply.c_str());
			set_state(Tango::ON);
			set_status("Source finding task failed!");
			return argout;
		}
	}//end loop reco		
	
	//Return reply
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());

	//Set free state	
	set_state(Tango::ON);
	set_status("Source finding ended");
	INFO_LOG("Source finding ended");

	/*----- PROTECTED REGION END -----*/	//	SFinder::extract_sources
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : SFinder::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void SFinder::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(SFinder::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::add_dynamic_commands
}

/*----- PROTECTED REGION ID(SFinder::namespace_ending) ENABLED START -----*/

//	Additional Methods
int SFinder::RunSourceTask(std::vector<Source*>& sources,const std::string& filename,long int tileMinX,long int tileMaxX,long int tileMinY,long int tileMaxY){

	//## Read input image
	INFO_LOG("Reading input image "<<filename<<" X["<<tileMinX<<","<<tileMaxX<<"] Y["<<tileMinY<<","<<tileMaxY<<"]...");
	Img* inputImg= ReadImage(filename,tileMinX,tileMaxX,tileMinY,tileMaxY);
	if(!inputImg){
		ERROR_LOG("Reading of input image failed!");
		return -1;
	}

	//## Find compact sources
	INFO_LOG("Searching compact sources...");
	std::vector<Source*> compact_sources;
	/*
	if(attr_searchCompactSources_write && FindCompactSources(compact_sources)<0){
		ERROR_LOG("Compact source search failed!");
		return -1;
	}
	*/

	//...
	//...

	//## Clear data
	inputImg->Delete();

	return 0;

}//close RunSourceTask()


int SFinder::FindSources(std::vector<Source*>& sources,Img* inputImg,double seedThr,double mergeThr,long int minNPix){

	if(!inputImg) return -1;

	//## Compute stats and bkg
	INFO_LOG("Computing image stats/bkg...");
	BkgData* bkgData= ComputeStatsAndBkg(inputImg);	
	if(!bkgData){
		ERROR_LOG("Failed to compute stats/bkg info!");
		return -1;
	}

	//## Compute significance map
	Img* significanceMap= inputImg->GetSignificanceMap(bkgData,attr_useLocalBkg_write);
	if(!significanceMap){
		ERROR_LOG("Failed to compute significance map!");
		delete bkgData;
		bkgData= 0;
		return -1;
	}

	//## Find sources
	INFO_LOG("Finding sources...");	
	int status= inputImg->FindCompactSource(
		sources,significanceMap,bkgData,
		seedThr,mergeThr,minNPix,attr_searchNegativeExcess_write,attr_mergeBelowSeed_write,
		attr_searchNestedSources_write,attr_nestedBlobThrFactor_write
	);

	if(status<0) {
		ERROR_LOG("Source finding failed!");
		delete bkgData;
		bkgData= 0;
		significanceMap->Delete();
		return -1;
	}
	int nSources= (int)sources.size();
	INFO_LOG(nSources<<" sources detected in input image...");	
	
	//## Clear allocated data
	delete bkgData;
	bkgData= 0;
	significanceMap->Delete();
		
	return 0;

}//close FindSources()


Img* SFinder::ReadImage(const std::string& filename,long int tileMinX,long int tileMaxX,long int tileMinY,long int tileMaxY){

	//## Check file
	FileInfo info;
	bool match_extension= false;
	if(!SysUtils::CheckFile(filename,info,match_extension,"")){
		ERROR_LOG("Invalid input file name specified (invalid file path?)!");
		return 0;
	}
	
	//=== ROOT reading ===
	Img* inputImg= 0;
	if(info.extension==".root"){// Read image from ROOT file
		TFile* inputFile = new TFile(filename.c_str(),"READ");
		if(!inputFile || inputFile->IsZombie()){
			ERROR_LOG("Cannot open input file "<<filename<<"!");
			return 0;
		}
		inputImg=  (Img*)inputFile->Get(filename.c_str());
		if(!inputImg){
			ERROR_LOG("Cannot get image from input file "<<filename<<"!");
			return 0;
		}
	}//close if

	//=== FITS reading ===
	else if(info.extension==".fits"){// Read image from FITS file
		inputImg= new Img;
		int status= inputImg->ReadFITS(filename,tileMinX,tileMaxX,tileMinY,tileMaxY); 
		if(status<0){
			ERROR_LOG("Failed to read image from input file "<<filename<<"!");
			if(inputImg) inputImg->Delete();
			return 0;
		}
	}//close else if

	//== Invalid extension ==
	else{
		ERROR_LOG("Invalid file extension detected (ext="<<info.extension<<")!");
		return 0;
	}
	inputImg->SetNameTitle("img","img");
	
	return inputImg;

}//close ReadImage()


BkgData* SFinder::ComputeStatsAndBkg(Img* img){

	//## Check input img
	if(!img){
		ERROR_LOG("Null ptr to input image given!");
		return 0;
	}

	//## Compute stats
	INFO_LOG("Computing image stats...");
	bool computeRobustStats= true;
	bool skipNegativePix= attr_skipNegativePixels_write;//false
	bool forceRecomputing= false;
	if(!img->ComputeStats(computeRobustStats,skipNegativePix,forceRecomputing)<0){
		ERROR_LOG("Stats computing failed!");
		return 0;
	}
	img->LogStats("INFO");

	//## Set local bkg grid/box
	//## If MetaData & beam info are available, interpret grid&box options as multiple of beam
	//## If no info is available (or use of beam info is off) interpret grid&box options as fractions wrt image size
	double boxSizeX= attr_localBkgBoxSizeX_write;
	double boxSizeY= attr_localBkgBoxSizeY_write;
	bool useBeamInfoInBkg= attr_useBeamInfoInBkg_write;
	long int nPixelsInBeam= 0;
	if(useBeamInfoInBkg && img->HasMetaData()){
		nPixelsInBeam= img->GetMetaData()->GetBeamSizeInPixel();	
	}
	
	if(useBeamInfoInBkg && nPixelsInBeam>0){
		INFO_LOG("Setting bkg boxes as ("<<attr_localBkgBoxSizeX_write<<","<<attr_localBkgBoxSizeY_write<<") x beam (beam="<<nPixelsInBeam<<" pixels) ...");
		boxSizeX= nPixelsInBeam*attr_localBkgBoxSizeX_write;
		boxSizeY= nPixelsInBeam*attr_localBkgBoxSizeY_write;
	}
	else{
		WARN_LOG("Beam information is not available or its usage has been turned off, using image fractions...");
		double Nx= img->GetNbinsX();
		double Ny= img->GetNbinsY();
		boxSizeX= attr_localBkgBoxSizeX_write*Nx;
		boxSizeY= attr_localBkgBoxSizeY_write*Ny;
	}

	double gridSizeX= attr_localBkgGridStepSizeX_write*boxSizeX;
	double gridSizeY= attr_localBkgGridStepSizeY_write*boxSizeY;

	//## Compute Bkg
	BkgData* bkgData= img->ComputeBkg(
		attr_bkgEstimator_write,attr_useLocalBkg_write,
		boxSizeX,boxSizeY,gridSizeX,gridSizeY,
		attr_use2ndPassInLocalBkg_write,attr_skipOutliersInLocalBkg_write,
		attr_seedThr_write,attr_mergeThr_write,attr_minNPix_write
	);

	if(!bkgData) {
		ERROR_LOG("Bkg computing failed!");
		return 0;
	}
		
	return bkgData;

}//close ComputeStatsAndBkg()

int SFinder::LoadDefaultConfig(){
	
	//Set default values in attributes (to be called in init_device method)
	//They will be overwritten after init_device completes with memorized DB values (if any)
	
	//--> Bkg options
	attr_useLocalBkg_write= useLocalBkg_default;
	attr_use2ndPassInLocalBkg_write= use2ndPassInLocalBkg_default;
	attr_skipOutliersInLocalBkg_write= skipOutliersInLocalBkg_default;
	attr_skipNegativePixels_write= skipNegativePixels_default;
	attr_localBkgMethod_write= localBkgMethod_default;
	attr_bkgEstimator_write= bkgEstimator_default;
	attr_useBeamInfoInBkg_write= useBeamInfoInBkg_default;
	attr_localBkgBoxSizeX_write= localBkgBoxSizeX_default;
	attr_localBkgBoxSizeY_write= localBkgBoxSizeY_default;
	attr_localBkgGridStepSizeX_write= localBkgGridStepSizeX_default;
	attr_localBkgGridStepSizeY_write= localBkgGridStepSizeY_default;

	//--> Source finding options
	attr_seedThr_write= seedThr_default;
	attr_mergeThr_write= mergeThr_default;
	attr_minNPix_write= minNPix_default;
	attr_mergeBelowSeed_write= mergeBelowSeed_default;
	attr_searchNegativeExcess_write= searchNegativeExcess_default;

	//--> Nested source search
	attr_searchNestedSources_write= searchNestedSources_default;
	attr_nestedBlobThrFactor_write= nestedBlobThrFactor_default;

	return 0;

}//close LoadDefaultConfig()


/*----- PROTECTED REGION END -----*/	//	SFinder::namespace_ending
} //	namespace
