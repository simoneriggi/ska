/*----- PROTECTED REGION ID(SFinder.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        SFinder.cpp
//
// description : C++ source for the SFinder class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SFinder are implemented in this file.
//
// project :     Source finder worker
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SFinder.h>
#include <SFinderClass.h>

//ROOT headers
#include <TFile.h>

//Caesar headers
#include <Img.h>
#include <BkgData.h>
#include <Contour.h>
#include <Logger.h>
#include <Serializer.h>
using namespace Caesar;

/*----- PROTECTED REGION END -----*/	//	SFinder.cpp

/**
 *  SFinder class description:
 *    Device server for source finding.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name    |  Method name
//================================================================
//  State           |  Inherited (no method)
//  Status          |  Inherited (no method)
//  ExtractSources  |  extract_sources
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  useLocalBkg               |  Tango::DevBoolean	Scalar
//  use2ndPassInLocalBkg      |  Tango::DevBoolean	Scalar
//  skipNegativePixels        |  Tango::DevBoolean	Scalar
//  skipOutliersInLocalBkg    |  Tango::DevBoolean	Scalar
//  localBkgMethod            |  Tango::DevShort	Scalar
//  bkgEstimator              |  Tango::DevShort	Scalar
//  useBeamInfoInBkg          |  Tango::DevBoolean	Scalar
//  localBkgBoxSizeX          |  Tango::DevFloat	Scalar
//  localBkgBoxSizeY          |  Tango::DevFloat	Scalar
//  localBkgGridStepSizeX     |  Tango::DevFloat	Scalar
//  localBkgGridStepSizeY     |  Tango::DevFloat	Scalar
//  seedThr                   |  Tango::DevFloat	Scalar
//  mergeThr                  |  Tango::DevFloat	Scalar
//  minNPix                   |  Tango::DevLong	Scalar
//  mergeBelowSeed            |  Tango::DevBoolean	Scalar
//  searchNegativeExcess      |  Tango::DevBoolean	Scalar
//  nestedBlobThrFactor       |  Tango::DevFloat	Scalar
//  searchCompactSources      |  Tango::DevBoolean	Scalar
//  selectCompactSources      |  Tango::DevBoolean	Scalar
//  useCircRatioCut           |  Tango::DevBoolean	Scalar
//  psCircRatioThr            |  Tango::DevFloat	Scalar
//  useElongCut               |  Tango::DevBoolean	Scalar
//  psElongThr                |  Tango::DevFloat	Scalar
//  useEllipseAreaRatioCut    |  Tango::DevBoolean	Scalar
//  psEllipseAreaRatioMinThr  |  Tango::DevFloat	Scalar
//  psEllipseAreaRatioMaxThr  |  Tango::DevFloat	Scalar
//  useMaxNPixCut             |  Tango::DevBoolean	Scalar
//  psMaxNPix                 |  Tango::DevLong	Scalar
//  useBoundingBoxCut         |  Tango::DevBoolean	Scalar
//  minBoundingBoxThr         |  Tango::DevFloat	Scalar
//================================================================

namespace SFinder_ns
{
/*----- PROTECTED REGION ID(SFinder::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	SFinder::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : SFinder::SFinder()
 *	Description : Constructors for a Tango device
 *                implementing the classSFinder
 */
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SFinder::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_1
}
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(SFinder::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_2
}
//--------------------------------------------------------
SFinder::SFinder(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(SFinder::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SFinder::delete_device()
{
	DEBUG_STREAM << "SFinder::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void SFinder::init_device()
{
	DEBUG_STREAM << "SFinder::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(SFinder::init_device) ENABLED START -----*/
	
	//	Initialize device
	set_state(Tango::ON);
	set_status("Worker "+device_name +" started");
	DEBUG_STREAM<<"SFinder::init_device() - Worker "<<device_name<<" started..."<<endl;

	//## Init default attr values
	LoadDefaultConfig();

	
	/*----- PROTECTED REGION END -----*/	//	SFinder::init_device
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void SFinder::get_device_property()
{
	/*----- PROTECTED REGION ID(SFinder::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("useLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("use2ndPassInLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("skipNegativePixels_default"));
	dev_prop.push_back(Tango::DbDatum("skipOutliersInLocalBkg_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgMethod_default"));
	dev_prop.push_back(Tango::DbDatum("bkgEstimator_default"));
	dev_prop.push_back(Tango::DbDatum("useBeamInfoInBkg_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgBoxSizeX_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgBoxSizeY_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgGridStepSizeX_default"));
	dev_prop.push_back(Tango::DbDatum("localBkgGridStepSizeY_default"));
	dev_prop.push_back(Tango::DbDatum("seedThr_default"));
	dev_prop.push_back(Tango::DbDatum("mergeThr_default"));
	dev_prop.push_back(Tango::DbDatum("minNPix_default"));
	dev_prop.push_back(Tango::DbDatum("mergeBelowSeed_default"));
	dev_prop.push_back(Tango::DbDatum("searchNegativeExcess_default"));
	dev_prop.push_back(Tango::DbDatum("searchNestedSources_default"));
	dev_prop.push_back(Tango::DbDatum("nestedBlobThrFactor_default"));
	dev_prop.push_back(Tango::DbDatum("searchCompactSources_default"));
	dev_prop.push_back(Tango::DbDatum("selectCompactSources_default"));
	dev_prop.push_back(Tango::DbDatum("useCircRatioCut_default"));
	dev_prop.push_back(Tango::DbDatum("psCircRatioThr_default"));
	dev_prop.push_back(Tango::DbDatum("useElongCut_default"));
	dev_prop.push_back(Tango::DbDatum("psElongThr_default"));
	dev_prop.push_back(Tango::DbDatum("useEllipseAreaRatioCut_default"));
	dev_prop.push_back(Tango::DbDatum("psEllipseAreaRatioMinThr_default"));
	dev_prop.push_back(Tango::DbDatum("psEllipseAreaRatioMaxThr_default"));
	dev_prop.push_back(Tango::DbDatum("useMaxNPixCut_default"));
	dev_prop.push_back(Tango::DbDatum("psMaxNPix_default"));
	dev_prop.push_back(Tango::DbDatum("useBoundingBoxCut_default"));
	dev_prop.push_back(Tango::DbDatum("minBoundingBoxThr_default"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SFinderClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SFinderClass	*ds_class =
			(static_cast<SFinderClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize useLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useLocalBkg_default;
		else {
			//	Try to initialize useLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useLocalBkg_default;
		}
		//	And try to extract useLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useLocalBkg_default;

		//	Try to initialize use2ndPassInLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  use2ndPassInLocalBkg_default;
		else {
			//	Try to initialize use2ndPassInLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  use2ndPassInLocalBkg_default;
		}
		//	And try to extract use2ndPassInLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  use2ndPassInLocalBkg_default;

		//	Try to initialize skipNegativePixels_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skipNegativePixels_default;
		else {
			//	Try to initialize skipNegativePixels_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skipNegativePixels_default;
		}
		//	And try to extract skipNegativePixels_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skipNegativePixels_default;

		//	Try to initialize skipOutliersInLocalBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  skipOutliersInLocalBkg_default;
		else {
			//	Try to initialize skipOutliersInLocalBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  skipOutliersInLocalBkg_default;
		}
		//	And try to extract skipOutliersInLocalBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  skipOutliersInLocalBkg_default;

		//	Try to initialize localBkgMethod_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgMethod_default;
		else {
			//	Try to initialize localBkgMethod_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgMethod_default;
		}
		//	And try to extract localBkgMethod_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgMethod_default;

		//	Try to initialize bkgEstimator_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  bkgEstimator_default;
		else {
			//	Try to initialize bkgEstimator_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  bkgEstimator_default;
		}
		//	And try to extract bkgEstimator_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  bkgEstimator_default;

		//	Try to initialize useBeamInfoInBkg_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useBeamInfoInBkg_default;
		else {
			//	Try to initialize useBeamInfoInBkg_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useBeamInfoInBkg_default;
		}
		//	And try to extract useBeamInfoInBkg_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useBeamInfoInBkg_default;

		//	Try to initialize localBkgBoxSizeX_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgBoxSizeX_default;
		else {
			//	Try to initialize localBkgBoxSizeX_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgBoxSizeX_default;
		}
		//	And try to extract localBkgBoxSizeX_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgBoxSizeX_default;

		//	Try to initialize localBkgBoxSizeY_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgBoxSizeY_default;
		else {
			//	Try to initialize localBkgBoxSizeY_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgBoxSizeY_default;
		}
		//	And try to extract localBkgBoxSizeY_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgBoxSizeY_default;

		//	Try to initialize localBkgGridStepSizeX_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgGridStepSizeX_default;
		else {
			//	Try to initialize localBkgGridStepSizeX_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgGridStepSizeX_default;
		}
		//	And try to extract localBkgGridStepSizeX_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgGridStepSizeX_default;

		//	Try to initialize localBkgGridStepSizeY_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  localBkgGridStepSizeY_default;
		else {
			//	Try to initialize localBkgGridStepSizeY_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  localBkgGridStepSizeY_default;
		}
		//	And try to extract localBkgGridStepSizeY_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  localBkgGridStepSizeY_default;

		//	Try to initialize seedThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  seedThr_default;
		else {
			//	Try to initialize seedThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  seedThr_default;
		}
		//	And try to extract seedThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  seedThr_default;

		//	Try to initialize mergeThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  mergeThr_default;
		else {
			//	Try to initialize mergeThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  mergeThr_default;
		}
		//	And try to extract mergeThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  mergeThr_default;

		//	Try to initialize minNPix_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  minNPix_default;
		else {
			//	Try to initialize minNPix_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  minNPix_default;
		}
		//	And try to extract minNPix_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  minNPix_default;

		//	Try to initialize mergeBelowSeed_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  mergeBelowSeed_default;
		else {
			//	Try to initialize mergeBelowSeed_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  mergeBelowSeed_default;
		}
		//	And try to extract mergeBelowSeed_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  mergeBelowSeed_default;

		//	Try to initialize searchNegativeExcess_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchNegativeExcess_default;
		else {
			//	Try to initialize searchNegativeExcess_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchNegativeExcess_default;
		}
		//	And try to extract searchNegativeExcess_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchNegativeExcess_default;

		//	Try to initialize searchNestedSources_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchNestedSources_default;
		else {
			//	Try to initialize searchNestedSources_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchNestedSources_default;
		}
		//	And try to extract searchNestedSources_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchNestedSources_default;

		//	Try to initialize nestedBlobThrFactor_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  nestedBlobThrFactor_default;
		else {
			//	Try to initialize nestedBlobThrFactor_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  nestedBlobThrFactor_default;
		}
		//	And try to extract nestedBlobThrFactor_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  nestedBlobThrFactor_default;

		//	Try to initialize searchCompactSources_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  searchCompactSources_default;
		else {
			//	Try to initialize searchCompactSources_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  searchCompactSources_default;
		}
		//	And try to extract searchCompactSources_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  searchCompactSources_default;

		//	Try to initialize selectCompactSources_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  selectCompactSources_default;
		else {
			//	Try to initialize selectCompactSources_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  selectCompactSources_default;
		}
		//	And try to extract selectCompactSources_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  selectCompactSources_default;

		//	Try to initialize useCircRatioCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useCircRatioCut_default;
		else {
			//	Try to initialize useCircRatioCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useCircRatioCut_default;
		}
		//	And try to extract useCircRatioCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useCircRatioCut_default;

		//	Try to initialize psCircRatioThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psCircRatioThr_default;
		else {
			//	Try to initialize psCircRatioThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psCircRatioThr_default;
		}
		//	And try to extract psCircRatioThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psCircRatioThr_default;

		//	Try to initialize useElongCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useElongCut_default;
		else {
			//	Try to initialize useElongCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useElongCut_default;
		}
		//	And try to extract useElongCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useElongCut_default;

		//	Try to initialize psElongThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psElongThr_default;
		else {
			//	Try to initialize psElongThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psElongThr_default;
		}
		//	And try to extract psElongThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psElongThr_default;

		//	Try to initialize useEllipseAreaRatioCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useEllipseAreaRatioCut_default;
		else {
			//	Try to initialize useEllipseAreaRatioCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useEllipseAreaRatioCut_default;
		}
		//	And try to extract useEllipseAreaRatioCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useEllipseAreaRatioCut_default;

		//	Try to initialize psEllipseAreaRatioMinThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psEllipseAreaRatioMinThr_default;
		else {
			//	Try to initialize psEllipseAreaRatioMinThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psEllipseAreaRatioMinThr_default;
		}
		//	And try to extract psEllipseAreaRatioMinThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psEllipseAreaRatioMinThr_default;

		//	Try to initialize psEllipseAreaRatioMaxThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psEllipseAreaRatioMaxThr_default;
		else {
			//	Try to initialize psEllipseAreaRatioMaxThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psEllipseAreaRatioMaxThr_default;
		}
		//	And try to extract psEllipseAreaRatioMaxThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psEllipseAreaRatioMaxThr_default;

		//	Try to initialize useMaxNPixCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useMaxNPixCut_default;
		else {
			//	Try to initialize useMaxNPixCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useMaxNPixCut_default;
		}
		//	And try to extract useMaxNPixCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useMaxNPixCut_default;

		//	Try to initialize psMaxNPix_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  psMaxNPix_default;
		else {
			//	Try to initialize psMaxNPix_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  psMaxNPix_default;
		}
		//	And try to extract psMaxNPix_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  psMaxNPix_default;

		//	Try to initialize useBoundingBoxCut_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  useBoundingBoxCut_default;
		else {
			//	Try to initialize useBoundingBoxCut_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  useBoundingBoxCut_default;
		}
		//	And try to extract useBoundingBoxCut_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  useBoundingBoxCut_default;

		//	Try to initialize minBoundingBoxThr_default from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  minBoundingBoxThr_default;
		else {
			//	Try to initialize minBoundingBoxThr_default from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  minBoundingBoxThr_default;
		}
		//	And try to extract minBoundingBoxThr_default value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  minBoundingBoxThr_default;

	}

	/*----- PROTECTED REGION ID(SFinder::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SFinder::always_executed_hook()
{
	DEBUG_STREAM << "SFinder::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void SFinder::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SFinder::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : SFinder::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void SFinder::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SFinder::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute useLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useLocalBkg_read);
	attr.set_value(&attr_useLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute useLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_useLocalBkg_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute use2ndPassInLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_use2ndPassInLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_use2ndPassInLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_use2ndPassInLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_use2ndPassInLocalBkg_read);
	attr.set_value(&attr_use2ndPassInLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_use2ndPassInLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute use2ndPassInLocalBkg related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_use2ndPassInLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_use2ndPassInLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_use2ndPassInLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_use2ndPassInLocalBkg_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_use2ndPassInLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute skipNegativePixels related method
 *	Description: Flag to skip/keep negative pixels when computing the image stats
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_skipNegativePixels(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_skipNegativePixels(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_skipNegativePixels) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_skipNegativePixels_read);
	attr.set_value(&attr_skipNegativePixels_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_skipNegativePixels
}
//--------------------------------------------------------
/**
 *	Write attribute skipNegativePixels related method
 *	Description: Flag to skip/keep negative pixels when computing the image stats
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_skipNegativePixels(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_skipNegativePixels(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_skipNegativePixels) ENABLED START -----*/
	attr.get_write_value(attr_skipNegativePixels_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_skipNegativePixels
}
//--------------------------------------------------------
/**
 *	Read attribute skipOutliersInLocalBkg related method
 *	Description: Flag to enable/disable skipping outliers in local bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_skipOutliersInLocalBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_skipOutliersInLocalBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_skipOutliersInLocalBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_skipOutliersInLocalBkg_read);
	attr.set_value(&attr_skipOutliersInLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_skipOutliersInLocalBkg
}
//--------------------------------------------------------
/**
 *	Write attribute skipOutliersInLocalBkg related method
 *	Description: Flag to enable/disable skipping outliers in local bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_skipOutliersInLocalBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_skipOutliersInLocalBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_skipOutliersInLocalBkg) ENABLED START -----*/
	attr.get_write_value(attr_skipOutliersInLocalBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_skipOutliersInLocalBkg
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgMethod related method
 *	Description: Method used to compute local bkg (1=Grid, 2=Superpixel)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgMethod(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgMethod(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgMethod) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgMethod_read);
	attr.set_value(&attr_localBkgMethod_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgMethod
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgMethod related method
 *	Description: Method used to compute local bkg (1=Grid, 2=Superpixel)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgMethod(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgMethod(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgMethod) ENABLED START -----*/
	attr.get_write_value(attr_localBkgMethod_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgMethod
}
//--------------------------------------------------------
/**
 *	Read attribute bkgEstimator related method
 *	Description: Estimator to be used to compute bkg 
 *               (1=mean, 2=median, 3=biweight, 4=clipped median)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_bkgEstimator(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_bkgEstimator(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_bkgEstimator) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_bkgEstimator_read);
	attr.set_value(&attr_bkgEstimator_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_bkgEstimator
}
//--------------------------------------------------------
/**
 *	Write attribute bkgEstimator related method
 *	Description: Estimator to be used to compute bkg 
 *               (1=mean, 2=median, 3=biweight, 4=clipped median)
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_bkgEstimator(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_bkgEstimator(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevShort	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_bkgEstimator) ENABLED START -----*/
	attr.get_write_value(attr_bkgEstimator_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_bkgEstimator
}
//--------------------------------------------------------
/**
 *	Read attribute useBeamInfoInBkg related method
 *	Description: Use beam information in bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useBeamInfoInBkg(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useBeamInfoInBkg(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useBeamInfoInBkg) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useBeamInfoInBkg_read);
	attr.set_value(&attr_useBeamInfoInBkg_write);
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useBeamInfoInBkg
}
//--------------------------------------------------------
/**
 *	Write attribute useBeamInfoInBkg related method
 *	Description: Use beam information in bkg computation
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useBeamInfoInBkg(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useBeamInfoInBkg(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useBeamInfoInBkg) ENABLED START -----*/
	attr.get_write_value(attr_useBeamInfoInBkg_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useBeamInfoInBkg
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgBoxSizeX related method
 *	Description: Box size X used for local bkg computation. If beam information is used, this corresponds to 
 *               a multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgBoxSizeX(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgBoxSizeX(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgBoxSizeX) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgBoxSizeX_read);
	attr.set_value(&attr_localBkgBoxSizeX_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgBoxSizeX
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgBoxSizeX related method
 *	Description: Box size X used for local bkg computation. If beam information is used, this corresponds to 
 *               a multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgBoxSizeX(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgBoxSizeX(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgBoxSizeX) ENABLED START -----*/
	attr.get_write_value(attr_localBkgBoxSizeX_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgBoxSizeX
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgBoxSizeY related method
 *	Description: Box size Y used for local bkg computation. If beam information is used, this corresponds to a
 *               multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgBoxSizeY(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgBoxSizeY(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgBoxSizeY) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgBoxSizeY_read);
	attr.set_value(&attr_localBkgBoxSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgBoxSizeY
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgBoxSizeY related method
 *	Description: Box size Y used for local bkg computation. If beam information is used, this corresponds to a
 *               multiple of beam size (e.g. x10, 20, 30 typically), otherwise it corresponds to a fraction of 
 *               image size.
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgBoxSizeY(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgBoxSizeY(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgBoxSizeY) ENABLED START -----*/
	attr.get_write_value(attr_localBkgBoxSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgBoxSizeY
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgGridStepSizeX related method
 *	Description: Grid step size X used in local bkg computation. This corresponds to a fraction of the box 
 *               size X (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgGridStepSizeX(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgGridStepSizeX(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgGridStepSizeX) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgGridStepSizeX_read);
	attr.set_value(&attr_localBkgGridStepSizeX_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgGridStepSizeX
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgGridStepSizeX related method
 *	Description: Grid step size X used in local bkg computation. This corresponds to a fraction of the box 
 *               size X (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgGridStepSizeX(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgGridStepSizeX(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgGridStepSizeX) ENABLED START -----*/
	attr.get_write_value(attr_localBkgGridStepSizeX_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgGridStepSizeX
}
//--------------------------------------------------------
/**
 *	Read attribute localBkgGridStepSizeY related method
 *	Description: Grid step size Y used in local bkg computation. This corresponds to a fraction of the box size Y 
 *               (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_localBkgGridStepSizeY(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_localBkgGridStepSizeY(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_localBkgGridStepSizeY) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_localBkgGridStepSizeY_read);
	attr.set_value(&attr_localBkgGridStepSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_localBkgGridStepSizeY
}
//--------------------------------------------------------
/**
 *	Write attribute localBkgGridStepSizeY related method
 *	Description: Grid step size Y used in local bkg computation. This corresponds to a fraction of the box size Y 
 *               (e.g. 0.2, 0.5 are typical values)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_localBkgGridStepSizeY(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_localBkgGridStepSizeY(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_localBkgGridStepSizeY) ENABLED START -----*/
	attr.get_write_value(attr_localBkgGridStepSizeY_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_localBkgGridStepSizeY
}
//--------------------------------------------------------
/**
 *	Read attribute seedThr related method
 *	Description: Seed threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_seedThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_seedThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_seedThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_seedThr_read);
	attr.set_value(&attr_seedThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_seedThr
}
//--------------------------------------------------------
/**
 *	Write attribute seedThr related method
 *	Description: Seed threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_seedThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_seedThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_seedThr) ENABLED START -----*/
	attr.get_write_value(attr_seedThr_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_seedThr
}
//--------------------------------------------------------
/**
 *	Read attribute mergeThr related method
 *	Description: Merge threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_mergeThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_mergeThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_mergeThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_mergeThr_read);
	attr.set_value(&attr_mergeThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_mergeThr
}
//--------------------------------------------------------
/**
 *	Write attribute mergeThr related method
 *	Description: Merge threshold (in number of sigmas above significance level) to be used in source 
 *               finding (flood-fill).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_mergeThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_mergeThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_mergeThr) ENABLED START -----*/
	attr.get_write_value(attr_mergeThr_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_mergeThr
}
//--------------------------------------------------------
/**
 *	Read attribute minNPix related method
 *	Description: Minimum number of pixels in source fnding (blob size in flood-fill).
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_minNPix(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_minNPix(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_minNPix) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_minNPix_read);
	attr.set_value(&attr_minNPix_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_minNPix
}
//--------------------------------------------------------
/**
 *	Write attribute minNPix related method
 *	Description: Minimum number of pixels in source fnding (blob size in flood-fill).
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_minNPix(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_minNPix(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_minNPix) ENABLED START -----*/
	attr.get_write_value(attr_minNPix_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_minNPix
}
//--------------------------------------------------------
/**
 *	Read attribute mergeBelowSeed related method
 *	Description: Flag value to aggregate only pixels below seed threshold in flood-fill
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_mergeBelowSeed(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_mergeBelowSeed(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_mergeBelowSeed) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_mergeBelowSeed_read);
	attr.set_value(&attr_mergeBelowSeed_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_mergeBelowSeed
}
//--------------------------------------------------------
/**
 *	Write attribute mergeBelowSeed related method
 *	Description: Flag value to aggregate only pixels below seed threshold in flood-fill
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_mergeBelowSeed(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_mergeBelowSeed(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_mergeBelowSeed) ENABLED START -----*/
	attr.get_write_value(attr_mergeBelowSeed_write);
	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_mergeBelowSeed
}
//--------------------------------------------------------
/**
 *	Read attribute searchNegativeExcess related method
 *	Description: Flag to search negative excess together with positive in compact source search
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_searchNegativeExcess(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_searchNegativeExcess(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_searchNegativeExcess) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_searchNegativeExcess_read);
	attr.set_value(&attr_searchNegativeExcess_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_searchNegativeExcess
}
//--------------------------------------------------------
/**
 *	Write attribute searchNegativeExcess related method
 *	Description: Flag to search negative excess together with positive in compact source search
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_searchNegativeExcess(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_searchNegativeExcess(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_searchNegativeExcess) ENABLED START -----*/
	attr.get_write_value(attr_searchNegativeExcess_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_searchNegativeExcess
}
//--------------------------------------------------------
/**
 *	Read attribute nestedBlobThrFactor related method
 *	Description: Threshold (in multiple of curvature RMS) to be used to detect nested blobs
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_nestedBlobThrFactor(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_nestedBlobThrFactor(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_nestedBlobThrFactor) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_nestedBlobThrFactor_read);
	attr.set_value(&attr_nestedBlobThrFactor_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_nestedBlobThrFactor
}
//--------------------------------------------------------
/**
 *	Write attribute nestedBlobThrFactor related method
 *	Description: Threshold (in multiple of curvature RMS) to be used to detect nested blobs
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_nestedBlobThrFactor(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_nestedBlobThrFactor(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_nestedBlobThrFactor) ENABLED START -----*/
	attr.get_write_value(attr_nestedBlobThrFactor_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_nestedBlobThrFactor
}
//--------------------------------------------------------
/**
 *	Read attribute searchCompactSources related method
 *	Description: Flag to enable/disable search of compact sources
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_searchCompactSources(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_searchCompactSources(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_searchCompactSources) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_searchCompactSources_read);
	attr.set_value(&attr_searchCompactSources_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_searchCompactSources
}
//--------------------------------------------------------
/**
 *	Write attribute searchCompactSources related method
 *	Description: Flag to enable/disable search of compact sources
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_searchCompactSources(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_searchCompactSources(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_searchCompactSources) ENABLED START -----*/
	attr.get_write_value(attr_searchCompactSources_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_searchCompactSources
}
//--------------------------------------------------------
/**
 *	Read attribute selectCompactSources related method
 *	Description: Flag to enable/disable selection of compact sources according to defined cuts
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_selectCompactSources(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_selectCompactSources(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_selectCompactSources) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_selectCompactSources_read);
	attr.set_value(&attr_selectCompactSources_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_selectCompactSources
}
//--------------------------------------------------------
/**
 *	Write attribute selectCompactSources related method
 *	Description: Flag to enable/disable selection of compact sources according to defined cuts
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_selectCompactSources(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_selectCompactSources(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_selectCompactSources) ENABLED START -----*/
	attr.get_write_value(attr_selectCompactSources_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_selectCompactSources
}
//--------------------------------------------------------
/**
 *	Read attribute useCircRatioCut related method
 *	Description: Use cut on circularity ratio in source selection
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useCircRatioCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useCircRatioCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useCircRatioCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useCircRatioCut_read);
	attr.set_value(&attr_useCircRatioCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useCircRatioCut
}
//--------------------------------------------------------
/**
 *	Write attribute useCircRatioCut related method
 *	Description: Use cut on circularity ratio in source selection
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useCircRatioCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useCircRatioCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useCircRatioCut) ENABLED START -----*/
	attr.get_write_value(attr_useCircRatioCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useCircRatioCut
}
//--------------------------------------------------------
/**
 *	Read attribute psCircRatioThr related method
 *	Description: Point-source circularity ratio cut. 
 *               Source is not selected as point-like if circratio<cut (circ ratio
 *               is =1 for a circle).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psCircRatioThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psCircRatioThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psCircRatioThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psCircRatioThr_read);
	attr.set_value(&attr_psCircRatioThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psCircRatioThr
}
//--------------------------------------------------------
/**
 *	Write attribute psCircRatioThr related method
 *	Description: Point-source circularity ratio cut. 
 *               Source is not selected as point-like if circratio<cut (circ ratio
 *               is =1 for a circle).
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psCircRatioThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psCircRatioThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psCircRatioThr) ENABLED START -----*/
	attr.get_write_value(attr_psCircRatioThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psCircRatioThr
}
//--------------------------------------------------------
/**
 *	Read attribute useElongCut related method
 *	Description: Flag to enable/disable elongation point-like source cut.
 *               Source is not selected as point-source if elong>cut (Elong=0 
 *               for circle/square).
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useElongCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useElongCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useElongCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useElongCut_read);
	attr.set_value(&attr_useElongCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useElongCut
}
//--------------------------------------------------------
/**
 *	Write attribute useElongCut related method
 *	Description: Flag to enable/disable elongation point-like source cut.
 *               Source is not selected as point-source if elong>cut (Elong=0 
 *               for circle/square).
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useElongCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useElongCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useElongCut) ENABLED START -----*/
	attr.get_write_value(attr_useElongCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useElongCut
}
//--------------------------------------------------------
/**
 *	Read attribute psElongThr related method
 *	Description: Elongation point-like source cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psElongThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psElongThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psElongThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psElongThr_read);
	attr.set_value(&attr_psElongThr_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psElongThr
}
//--------------------------------------------------------
/**
 *	Write attribute psElongThr related method
 *	Description: Elongation point-like source cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psElongThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psElongThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psElongThr) ENABLED START -----*/
	attr.get_write_value(attr_psElongThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psElongThr
}
//--------------------------------------------------------
/**
 *	Read attribute useEllipseAreaRatioCut related method
 *	Description:  Flag to enable/disable ellipse area ratio cut
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useEllipseAreaRatioCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useEllipseAreaRatioCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useEllipseAreaRatioCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useEllipseAreaRatioCut_read);
	attr.set_value(&attr_useEllipseAreaRatioCut_write);	
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useEllipseAreaRatioCut
}
//--------------------------------------------------------
/**
 *	Write attribute useEllipseAreaRatioCut related method
 *	Description:  Flag to enable/disable ellipse area ratio cut
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useEllipseAreaRatioCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useEllipseAreaRatioCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useEllipseAreaRatioCut) ENABLED START -----*/
	attr.get_write_value(attr_useEllipseAreaRatioCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useEllipseAreaRatioCut
}
//--------------------------------------------------------
/**
 *	Read attribute psEllipseAreaRatioMinThr related method
 *	Description: Min Ellipse Area Ratio cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psEllipseAreaRatioMinThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psEllipseAreaRatioMinThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psEllipseAreaRatioMinThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psEllipseAreaRatioMinThr_read);
	attr.set_value(&attr_psEllipseAreaRatioMinThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psEllipseAreaRatioMinThr
}
//--------------------------------------------------------
/**
 *	Write attribute psEllipseAreaRatioMinThr related method
 *	Description: Min Ellipse Area Ratio cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psEllipseAreaRatioMinThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psEllipseAreaRatioMinThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psEllipseAreaRatioMinThr) ENABLED START -----*/
	attr.get_write_value(attr_psEllipseAreaRatioMinThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psEllipseAreaRatioMinThr
}
//--------------------------------------------------------
/**
 *	Read attribute psEllipseAreaRatioMaxThr related method
 *	Description: Max Ellipse Area Ratio cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psEllipseAreaRatioMaxThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psEllipseAreaRatioMaxThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psEllipseAreaRatioMaxThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psEllipseAreaRatioMaxThr_read);
	attr.set_value(&attr_psEllipseAreaRatioMaxThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psEllipseAreaRatioMaxThr
}
//--------------------------------------------------------
/**
 *	Write attribute psEllipseAreaRatioMaxThr related method
 *	Description: Max Ellipse Area Ratio cut
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psEllipseAreaRatioMaxThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psEllipseAreaRatioMaxThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psEllipseAreaRatioMaxThr) ENABLED START -----*/
	attr.get_write_value(attr_psEllipseAreaRatioMaxThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psEllipseAreaRatioMaxThr
}
//--------------------------------------------------------
/**
 *	Read attribute useMaxNPixCut related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useMaxNPixCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useMaxNPixCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useMaxNPixCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useMaxNPixCut_read);
	attr.set_value(&attr_useMaxNPixCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useMaxNPixCut
}
//--------------------------------------------------------
/**
 *	Write attribute useMaxNPixCut related method
 *	Description: 
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useMaxNPixCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useMaxNPixCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useMaxNPixCut) ENABLED START -----*/
	attr.get_write_value(attr_useMaxNPixCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useMaxNPixCut
}
//--------------------------------------------------------
/**
 *	Read attribute psMaxNPix related method
 *	Description: Maximum number of pixels to select point-like sources
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_psMaxNPix(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_psMaxNPix(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_psMaxNPix) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_psMaxNPix_read);
	attr.set_value(&attr_psMaxNPix_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_psMaxNPix
}
//--------------------------------------------------------
/**
 *	Write attribute psMaxNPix related method
 *	Description: Maximum number of pixels to select point-like sources
 *
 *	Data type:	Tango::DevLong
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_psMaxNPix(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_psMaxNPix(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevLong	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_psMaxNPix) ENABLED START -----*/
	attr.get_write_value(attr_psMaxNPix_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_psMaxNPix
}
//--------------------------------------------------------
/**
 *	Read attribute useBoundingBoxCut related method
 *	Description: Flag to enable/disable bounding box cut
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_useBoundingBoxCut(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_useBoundingBoxCut(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_useBoundingBoxCut) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_useBoundingBoxCut_read);
	attr.set_value(&attr_useBoundingBoxCut_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_useBoundingBoxCut
}
//--------------------------------------------------------
/**
 *	Write attribute useBoundingBoxCut related method
 *	Description: Flag to enable/disable bounding box cut
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_useBoundingBoxCut(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_useBoundingBoxCut(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevBoolean	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_useBoundingBoxCut) ENABLED START -----*/
	attr.get_write_value(attr_useBoundingBoxCut_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_useBoundingBoxCut
}
//--------------------------------------------------------
/**
 *	Read attribute minBoundingBoxThr related method
 *	Description: Minimum default bounding box cut (source tagged as bad if below this threshold)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::read_minBoundingBoxThr(Tango::Attribute &attr)
{
	DEBUG_STREAM << "SFinder::read_minBoundingBoxThr(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(SFinder::read_minBoundingBoxThr) ENABLED START -----*/
	//	Set the attribute value
	//attr.set_value(attr_minBoundingBoxThr_read);
	attr.set_value(&attr_minBoundingBoxThr_write);

	/*----- PROTECTED REGION END -----*/	//	SFinder::read_minBoundingBoxThr
}
//--------------------------------------------------------
/**
 *	Write attribute minBoundingBoxThr related method
 *	Description: Minimum default bounding box cut (source tagged as bad if below this threshold)
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void SFinder::write_minBoundingBoxThr(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "SFinder::write_minBoundingBoxThr(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(SFinder::write_minBoundingBoxThr) ENABLED START -----*/
	attr.get_write_value(attr_minBoundingBoxThr_write);
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::write_minBoundingBoxThr
}

//--------------------------------------------------------
/**
 *	Method      : SFinder::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void SFinder::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(SFinder::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command ExtractSources related method
 *	Description: Find sources in map using the configuration passed 
 *               as argument.
 *
 *	@param argin String arg
 *               [0]: filename 
 *               
 *               Long arg
 *               [nmaps+0]: tile min x
 *               [nmaps+1]: tile max x
 *               [nmaps+2]: tile min y
 *               [nmaps+3]: tile max y
 *	@returns Long arg
 *           [0]: ack code
 *           
 *           String arg
 *           [0]: Encoded sources found
 *           [1]: err description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SFinder::extract_sources(const Tango::DevVarLongStringArray *argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SFinder::ExtractSources()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SFinder::extract_sources) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(2);

	//Validate args	
	long int nArgs_s= argin->svalue.length();
	long int nArgs_l= argin->lvalue.length();
	if(nArgs_s<=0){
		WARN_LOG("Missing filename argument given!");
		ack= -1;
		reply= "Missing filename argument given!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	if(strcmp(argin->svalue[0],"")==0){
		WARN_LOG("Empty filename argument given!");
		ack= -1;
		reply= "Invalid filename argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	if(nArgs_l%4!=0){
		WARN_LOG("Invalid image range argument given!");
		ack= -1;
		reply= "Invalid image range argument given!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	
	std::string inputFileName= std::string(argin->svalue[0]); 
	long int nTasks= (long int)(nArgs_l/4);	
	std::vector<long int> tileMinX_list(nTasks,-1);
	std::vector<long int> tileMaxX_list(nTasks,-1);
	std::vector<long int> tileMinY_list(nTasks,-1);
	std::vector<long int> tileMaxY_list(nTasks,-1);	
	if(nArgs_l>0){
		INFO_LOG("Reading tile image(s)...");
		for(long int i=0;i<nTasks;i++){
			long int index= 4*i;
			tileMinX_list[i]= argin->lvalue[index+0]; 
			tileMaxX_list[i]= argin->lvalue[index+1];
			tileMinY_list[i]= argin->lvalue[index+2]; 
			tileMaxY_list[i]= argin->lvalue[index+3];
		}
	}
	
	//Set RUNNING state
	set_state(Tango::RUNNING);
	set_status("Source finding started");
	INFO_LOG("Source finding started");

	
	//## Source finding tasks
	INFO_LOG("Starting source finding tasks (Ntasks="<<nTasks<<") ...");
	std::vector<Source*> sources;
	for(long int i=0;i<nTasks;i++){
		INFO_LOG("Starting source finding task no. "<<i+1<<"...");
		int status= RunSourceTask(sources,inputFileName,tileMinX_list[i],tileMaxX_list[i],tileMinY_list[i],tileMaxY_list[i]);
		if(status<0){
			//Clear sources
			for(unsigned int k=0;k<sources.size();k++){
				if(sources[k]){
					delete sources[k];
					sources[k]= 0;
				}
			}
			sources.clear();

			//Set error reply
			ERROR_LOG("Source finding task failed for reco task no. "<<i+1<<"!");
			ack= -1;
			reply= "Source finding task failed!";
			argout->lvalue[0]= ack;
			argout->svalue[0] = CORBA::string_dup(reply.c_str());
			set_state(Tango::ON);
			set_status("Source finding task failed!");
			return argout;
		}

		INFO_LOG("#"<<sources.size()<<" sources found in task no. "<<i+1<<"...");

	}//end loop reco

	
	//## Encode source list 
	std::string serialized_sources= "";
	if(sources.size()>0){
		INFO_LOG("Serializing source collection (nsources="<<sources.size()<<")");
		int status= Serializer::SourceCollectionToString(sources,serialized_sources);
		if(status<0){
			//Clear sources
			for(unsigned int k=0;k<sources.size();k++){
				if(sources[k]){
					delete sources[k];
					sources[k]= 0;
				}
			}
			sources.clear();

			//Set error reply
			ERROR_LOG("Source serialization failed!");
			ack= -1;
			reply= "Source serialization failed!";
			argout->lvalue[0]= ack;
			argout->svalue[0] = CORBA::string_dup(reply.c_str());
			set_state(Tango::ON);
			set_status("Source serialization failed!");
			return argout;
		}
	}
	
	//Return reply
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());
	argout->svalue[1] = CORBA::string_dup(serialized_sources.c_str());
	

	//Set free state	
	set_state(Tango::ON);
	set_status("Source finding ended");
	INFO_LOG("Source finding ended");

	//Clear sources
	for(unsigned int k=0;k<sources.size();k++){
		if(sources[k]){
			delete sources[k];
			sources[k]= 0;
		}
	}
	sources.clear();

	/*----- PROTECTED REGION END -----*/	//	SFinder::extract_sources
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : SFinder::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void SFinder::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(SFinder::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	SFinder::add_dynamic_commands
}

/*----- PROTECTED REGION ID(SFinder::namespace_ending) ENABLED START -----*/

//	Additional Methods
int SFinder::RunSourceTask(std::vector<Source*>& sources,const std::string& filename,long int tileMinX,long int tileMaxX,long int tileMinY,long int tileMaxY){

	//## Read input image
	INFO_LOG("Reading input image "<<filename<<" X["<<tileMinX<<","<<tileMaxX<<"] Y["<<tileMinY<<","<<tileMaxY<<"]...");
	Img* inputImg= ReadImage(filename,tileMinX,tileMaxX,tileMinY,tileMaxY);
	if(!inputImg){
		ERROR_LOG("Reading of input image failed!");
		return -1;
	}

	//## Compute input image stats & bkg
	INFO_LOG("Computing input image stats & bkg...");	
	BkgData* bkgData= ComputeStatsAndBkg(inputImg);	
	if(!bkgData){
		ERROR_LOG("ERROR: Failed to compute stats/bkg info!");
		inputImg->Delete();
		return -1;
	}

	//## Find compact sources
	INFO_LOG("Searching compact sources...");
	std::vector<Source*> compact_sources;
	if(attr_searchCompactSources_write && FindCompactSources(compact_sources,inputImg,false,bkgData)<0){
		ERROR_LOG("Compact source search failed!");
		return -1;
	}
	sources.insert(sources.end(),compact_sources.begin(),compact_sources.end());
	

	//...
	//...

	//## Clear data
	inputImg->Delete();
	delete bkgData;
	bkgData= 0;

	return 0;

}//close RunSourceTask()


int SFinder::FindCompactSources(std::vector<Source*>& sources,Img* inputImg,bool computeStatsAndBkg,BkgData* inputBkgData){

	//## Check input image
	if(!inputImg) {
		ERROR_LOG("Null ptr to input image given!");
		return -1;
	}

	//## Find sources
	INFO_LOG("Finding compact sources ...");		
	int status= FindSources(sources,inputImg,computeStatsAndBkg,inputBkgData);
	if(status<0) {
		ERROR_LOG("Compact source finding failed!");
		return -1;
	}

	//## Retrieve found sources 
	int nSources= (int)sources.size();
	INFO_LOG("#"<<nSources<<" compact sources detected in input image...");
	if(nSources<=0) return 0;

	//## Apply source selection?
	int nSelSources= nSources;
	if(attr_selectCompactSources_write){
		if(SelectSources(sources)<0){
			ERROR_LOG("Failed to select sources!");
			return -1;
		}
		nSelSources= sources.size();
	}//close if source selection

	//## Add detected sources to the list	
	INFO_LOG("#"<<nSelSources<<" compact sources selected after cuts...");

	return 0;

}//close FindCompactSources()


int SFinder::FindSources(std::vector<Source*>& sources,Img* inputImg,bool computeStatsAndBkg,BkgData* inputBkgData){

	//## Check input image
	if(!inputImg) {
		ERROR_LOG("Null ptr to input image given!");
		return -1;
	}

	//## Compute stats and bkg?
	BkgData* bkgData= inputBkgData;
	if(computeStatsAndBkg || !bkgData){
		INFO_LOG("Computing image stats/bkg...");
		bkgData= ComputeStatsAndBkg(inputImg);	
		if(!bkgData){
			ERROR_LOG("Failed to compute stats/bkg info!");
			return -1;
		}
	}

	//## Compute significance map
	Img* significanceMap= inputImg->GetSignificanceMap(bkgData,attr_useLocalBkg_write);
	if(!significanceMap){
		ERROR_LOG("Failed to compute significance map!");
		if(!inputBkgData){//delete only if inputBkgData is null (e.g. bkg is computed here)
			delete bkgData;
			bkgData= 0;
		}
		return -1;
	}

	//## Find sources
	INFO_LOG("Finding sources...");	
	int status= inputImg->FindCompactSource(
		sources,significanceMap,bkgData,
		attr_seedThr_write,attr_mergeThr_write,attr_minNPix_write,attr_searchNegativeExcess_write,attr_mergeBelowSeed_write,
		attr_searchNestedSources_write,attr_nestedBlobThrFactor_write
	);

	if(status<0) {
		ERROR_LOG("Source finding failed!");
		if(!inputBkgData){
			delete bkgData;
			bkgData= 0;
		}
		significanceMap->Delete();
		return -1;
	}
	int nSources= (int)sources.size();
	INFO_LOG(nSources<<" sources detected in input image...");	
	
	//## Clear allocated data
	if(!inputBkgData){
		delete bkgData;
		bkgData= 0;
	}
	significanceMap->Delete();
		
	return 0;

}//close FindSources()


int SFinder::SelectSources(std::vector<Source*>& sources){

	//## Apply source selection?
	int nSources= (int)sources.size();
	if(nSources<=0) return 0;
	
	int nSelSources= 0;
	std::vector<Source*> sources_sel;

	for(int i=0;i<nSources;i++){	
		std::string sourceName= sources[i]->Name;
		int sourceId= sources[i]->Id;
		long int NPix= sources[i]->NPix;
		double X0= sources[i]->X0;
		double Y0= sources[i]->Y0;

		//Is bad source (i.e. line-like blob, etc...)?
		if(!IsGoodSource(sources[i])) {
			DEBUG_LOG("Source no. "<<i<<" (name="<<sourceName<<",id="<<sourceId<<", n="<<NPix<<"("<<X0<<","<<Y0<<")) tagged as bad source, skipped!");
			sources[i]->SetGoodSourceFlag(false);
			continue;
		}
			
		//Is point-like source?
		if( IsPointLikeSource(sources[i]) ){
			DEBUG_LOG("Source no. "<<i<<" (name="<<sourceName<<",id="<<sourceId<<", n="<<NPix<<"("<<X0<<","<<Y0<<")) tagged as a point-like source ...");
			sources[i]->SetType(Source::ePointLike);
		}

		//Tag nested sources
		std::vector<Source*> nestedSources= sources[i]->GetNestedSources();
		for(unsigned int j=0;j<nestedSources.size();j++){
			std::string nestedSourceName= nestedSources[j]->Name;
			int nestedSourceId= nestedSources[j]->Id;
			long int nestedNPix= nestedSources[j]->NPix;
			double nestedX0= nestedSources[j]->X0;
			double nestedY0= nestedSources[j]->Y0;

			if(!IsGoodSource(nestedSources[j])) {
				DEBUG_LOG("Source no. "<<i<<": nested source no. "<<j<<" (name="<<nestedSourceName<<",id="<<nestedSourceId<<", n="<<nestedNPix<<"("<<nestedX0<<","<<nestedY0<<")) tagged as bad source, skipped!");
				nestedSources[j]->SetGoodSourceFlag(false);
			}
			if( IsPointLikeSource(nestedSources[j]) ){
				DEBUG_LOG("Source no. "<<i<<": nested source no. "<<j<<" (name="<<nestedSourceName<<",id="<<nestedSourceId<<", n="<<nestedNPix<<"("<<nestedX0<<","<<nestedY0<<")) tagged as a point-like source ...");
				nestedSources[j]->SetType(Source::ePointLike);
			}
		}//end loop nested sources
			
		//Add source to the list	
		sources_sel.push_back(sources[i]);
		nSelSources++;
	}//end loop sources

	INFO_LOG("Added "<<nSelSources<<" compact sources to the selected list...");

	//Clear initial vector (DO NOT CLEAR MEMORY!) and fill with selection (then reset selection)
	sources.clear();
	sources.insert(sources.end(),sources_sel.begin(),sources_sel.end());
	sources_sel.clear();

	return 0;

}//close SelectSources()

bool SFinder::IsGoodSource(Source* aSource){
	
	if(!aSource) return false;

	//## Check for pixels 	
	if(aSource->NPix<=0 || (aSource->GetPixels()).size()<=0) return false;

	//## Check for line-like source
	if( (aSource->GetContours()).size()<=0) {
		WARN_LOG("No contour stored for this source, cannot perform check!");
		return true;
	}

	double BoundingBoxMin= ((aSource->GetContours())[0])->BoundingBoxMin;
	if(attr_useBoundingBoxCut_write && BoundingBoxMin<attr_minBoundingBoxThr_write) {
		DEBUG_LOG("BoundingBox cut not passed (BoundingBoxMin="<<BoundingBoxMin<<"<"<<attr_minBoundingBoxThr_write<<")");
		return false;
	}

	//## Add other check here ...
	//...

	return true;

}//close IsGoodSource()

bool SFinder::IsPointLikeSource(Source* aSource){

	if(!aSource) return false;
	if(!aSource->HasParameters()) {
		WARN_LOG("No parameters are available for this source (did you compute them?)...point-like check cannot be performed!");
		return true;
	}

	std::string sourceName= aSource->Name;
	int sourceId= aSource->Id;

	//Loop over contours and check if all of them have circular features
	bool isPointLike= true;
	std::vector<Contour*> contours= aSource->GetContours();

	for(unsigned int i=0;i<contours.size();i++){
		Contour* thisContour= contours[i];

		//Test circularity ratio: 1= circle
		if(attr_useCircRatioCut_write && thisContour->CircularityRatio<attr_psCircRatioThr_write) {
			DEBUG_LOG("Source (name="<<sourceName<<","<<"id="<<sourceId<<") does not pass CircularityRatio cut (CR="<<thisContour->CircularityRatio<<"<"<<attr_psCircRatioThr_write<<")");
			isPointLike= false;
			break;
		}

		//Test elongation (how symmetrical is the shape): 0=circle,square
		if(attr_useElongCut_write && thisContour->Elongation>attr_psElongThr_write) {
			DEBUG_LOG("Source (name="<<sourceName<<","<<"id="<<sourceId<<") does not pass Elongation cut (ELONG="<<thisContour->CircularityRatio<<">"<<attr_psElongThr_write<<")");
			isPointLike= false;
			break;	
		}

		//Test ellipse fit
		if(attr_useEllipseAreaRatioCut_write && (thisContour->EllipseAreaRatio<attr_psEllipseAreaRatioMinThr_write || thisContour->EllipseAreaRatio>attr_psEllipseAreaRatioMaxThr_write)) {
			DEBUG_LOG("Source (name="<<sourceName<<","<<"id="<<sourceId<<") does not pass EllipseAreaRatio cut (EAR="<<thisContour->EllipseAreaRatio<<" outside range ["<<attr_psEllipseAreaRatioMinThr_write<<","<<attr_psEllipseAreaRatioMaxThr_write<<"])");
			isPointLike= false;
			break;	
		}

	}//end contour loop
	
	//Check number of pixels
	if(attr_useMaxNPixCut_write && aSource->NPix>attr_psMaxNPix_write){
		DEBUG_LOG("Source (name="<<sourceName<<","<<"id="<<sourceId<<") does not pass nMaxPix cut (NPix="<<aSource->NPix<<">"<<attr_psMaxNPix_write<<")");
		isPointLike= false;
	}

	if(!isPointLike) return false;

	return true;

}//close IsPointLikeSource()

Img* SFinder::ReadImage(const std::string& filename,long int tileMinX,long int tileMaxX,long int tileMinY,long int tileMaxY){

	//## Check file
	FileInfo info;
	bool match_extension= false;
	if(!SysUtils::CheckFile(filename,info,match_extension,"")){
		ERROR_LOG("Invalid input file name specified (invalid file path?)!");
		return 0;
	}
	
	//=== ROOT reading ===
	Img* inputImg= 0;
	if(info.extension==".root"){// Read image from ROOT file
		TFile* inputFile = new TFile(filename.c_str(),"READ");
		if(!inputFile || inputFile->IsZombie()){
			ERROR_LOG("Cannot open input file "<<filename<<"!");
			return 0;
		}
		inputImg=  (Img*)inputFile->Get(filename.c_str());
		if(!inputImg){
			ERROR_LOG("Cannot get image from input file "<<filename<<"!");
			return 0;
		}
	}//close if

	//=== FITS reading ===
	else if(info.extension==".fits"){// Read image from FITS file
		inputImg= new Img;
		int status= inputImg->ReadFITS(filename,tileMinX,tileMaxX,tileMinY,tileMaxY); 
		if(status<0){
			ERROR_LOG("Failed to read image from input file "<<filename<<"!");
			if(inputImg) inputImg->Delete();
			return 0;
		}
	}//close else if

	//== Invalid extension ==
	else{
		ERROR_LOG("Invalid file extension detected (ext="<<info.extension<<")!");
		return 0;
	}
	inputImg->SetNameTitle("img","img");
	
	return inputImg;

}//close ReadImage()


BkgData* SFinder::ComputeStatsAndBkg(Img* img){

	//## Check input img
	if(!img){
		ERROR_LOG("Null ptr to input image given!");
		return 0;
	}

	//## Compute stats
	INFO_LOG("Computing image stats...");
	bool computeRobustStats= true;
	bool skipNegativePix= attr_skipNegativePixels_write;//false
	bool forceRecomputing= false;
	if(!img->ComputeStats(computeRobustStats,skipNegativePix,forceRecomputing)<0){
		ERROR_LOG("Stats computing failed!");
		return 0;
	}
	img->LogStats("INFO");

	//## Set local bkg grid/box
	//## If MetaData & beam info are available, interpret grid&box options as multiple of beam
	//## If no info is available (or use of beam info is off) interpret grid&box options as fractions wrt image size
	double boxSizeX= attr_localBkgBoxSizeX_write;
	double boxSizeY= attr_localBkgBoxSizeY_write;
	bool useBeamInfoInBkg= attr_useBeamInfoInBkg_write;
	long int nPixelsInBeam= 0;
	if(useBeamInfoInBkg && img->HasMetaData()){
		nPixelsInBeam= img->GetMetaData()->GetBeamSizeInPixel();	
	}
	
	if(useBeamInfoInBkg && nPixelsInBeam>0){
		INFO_LOG("Setting bkg boxes as ("<<attr_localBkgBoxSizeX_write<<","<<attr_localBkgBoxSizeY_write<<") x beam (beam="<<nPixelsInBeam<<" pixels) ...");
		boxSizeX= nPixelsInBeam*attr_localBkgBoxSizeX_write;
		boxSizeY= nPixelsInBeam*attr_localBkgBoxSizeY_write;
	}
	else{
		WARN_LOG("Beam information is not available or its usage has been turned off, using image fractions...");
		double Nx= img->GetNbinsX();
		double Ny= img->GetNbinsY();
		boxSizeX= attr_localBkgBoxSizeX_write*Nx;
		boxSizeY= attr_localBkgBoxSizeY_write*Ny;
	}

	double gridSizeX= attr_localBkgGridStepSizeX_write*boxSizeX;
	double gridSizeY= attr_localBkgGridStepSizeY_write*boxSizeY;
	INFO_LOG("Bkg box ("<<boxSizeX<<","<<boxSizeY<<") pixels, Grid step ("<<gridSizeX<<","<<gridSizeY<<") pixels ...");
		
	//## Compute Bkg
	BkgData* bkgData= img->ComputeBkg(
		attr_bkgEstimator_write,attr_useLocalBkg_write,
		boxSizeX,boxSizeY,gridSizeX,gridSizeY,
		attr_use2ndPassInLocalBkg_write,attr_skipOutliersInLocalBkg_write,
		attr_seedThr_write,attr_mergeThr_write,attr_minNPix_write
	);

	if(!bkgData) {
		ERROR_LOG("Bkg computing failed!");
		return 0;
	}
		
	return bkgData;

}//close ComputeStatsAndBkg()

int SFinder::LoadDefaultConfig(){
	
	//Set default values in attributes (to be called in init_device method)
	//They will be overwritten after init_device completes with memorized DB values (if any)
	
	//--> Bkg options
	attr_useLocalBkg_write= useLocalBkg_default;
	attr_use2ndPassInLocalBkg_write= use2ndPassInLocalBkg_default;
	attr_skipOutliersInLocalBkg_write= skipOutliersInLocalBkg_default;
	attr_skipNegativePixels_write= skipNegativePixels_default;
	attr_localBkgMethod_write= localBkgMethod_default;
	attr_bkgEstimator_write= bkgEstimator_default;
	attr_useBeamInfoInBkg_write= useBeamInfoInBkg_default;
	attr_localBkgBoxSizeX_write= localBkgBoxSizeX_default;
	attr_localBkgBoxSizeY_write= localBkgBoxSizeY_default;
	attr_localBkgGridStepSizeX_write= localBkgGridStepSizeX_default;
	attr_localBkgGridStepSizeY_write= localBkgGridStepSizeY_default;

	//--> Source finding options
	attr_searchCompactSources_write= searchCompactSources_default;
	attr_seedThr_write= seedThr_default;
	attr_mergeThr_write= mergeThr_default;
	attr_minNPix_write= minNPix_default;
	attr_mergeBelowSeed_write= mergeBelowSeed_default;
	attr_searchNegativeExcess_write= searchNegativeExcess_default;

	//--> Nested source search
	attr_searchNestedSources_write= searchNestedSources_default;
	attr_nestedBlobThrFactor_write= nestedBlobThrFactor_default;

	//--> Source selection
	attr_selectCompactSources_write= selectCompactSources_default;
	attr_useCircRatioCut_write= useCircRatioCut_default;
	attr_psCircRatioThr_write= psCircRatioThr_default;
	attr_useElongCut_write= useElongCut_default;
	attr_psElongThr_write= psElongThr_default;
	attr_useEllipseAreaRatioCut_write= useEllipseAreaRatioCut_default;
	attr_psEllipseAreaRatioMinThr_write= psEllipseAreaRatioMinThr_default;
	attr_psEllipseAreaRatioMaxThr_write= psEllipseAreaRatioMaxThr_default;
	attr_useMaxNPixCut_write= useMaxNPixCut_default;
	attr_psMaxNPix_write= psMaxNPix_default;
	attr_useBoundingBoxCut_write= useBoundingBoxCut_default;
	attr_minBoundingBoxThr_write= minBoundingBoxThr_default;

	return 0;

}//close LoadDefaultConfig()


/*----- PROTECTED REGION END -----*/	//	SFinder::namespace_ending
} //	namespace
